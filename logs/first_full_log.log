2025-07-14 14:45:14,850 - INFO - ==================== 開始新的自我優化流程 ====================
2025-07-14 14:45:14,851 - INFO - 任務: Solve the Traveling Salesman Problem (TSP) for a given set of 2D points.
            The goal is to find the shortest possible tour that visits each point exactly once and returns to the origin point.
            The distance between points is the Euclidean distance.
2025-07-14 14:45:14,851 - INFO - 最大迭代次數: 6, 無進步停止閾值: 2
2025-07-14 14:45:14,851 - INFO - 
--- [呼叫 Gemini] Iteration 1 ---
2025-07-14 14:45:14,851 - INFO - --- [傳送的 Prompt] ---

Task Description: 
            Solve the Traveling Salesman Problem (TSP) for a given set of 2D points.
            The goal is to find the shortest possible tour that visits each point exactly once and returns to the origin point.
            The distance between points is the Euclidean distance.
            

Analyze the computational complexity of the described task. Based on your analysis, classify the problem into one of two categories:
1.  **Definite Algorithm Feasible (DP-like)**: A category for problems where an exact, optimal solution can be found in a reasonable, predictable amount of time (e.g., polynomial time).
2.  **Indefinite Algorithm Required (Heuristic/NP-Hard)**: A category for problems where finding a guaranteed optimal solution is computationally infeasible, thus requiring heuristic or approximation strategies.

Start your response with the classification in the format: "Classification: [Your Classification]".

Then, provide your reasoning. If you classify it as 'Definite Algorithm Feasible', describe a suitable exact algorithm. If you classify it as 'Indefinite Algorithm Required', propose an effective heuristic algorithm to start with.

--------------------
2025-07-14 14:45:49,729 - INFO - --- [Gemini 回應] (耗時: 34.88 秒) ---
Classification: Indefinite Algorithm Required (Heuristic/NP-Hard)

### Reasoning

The Traveling Salesman Problem (TSP) is a classic NP-hard problem in combinatorial optimization. Here's an analysis of its computational complexity:

1.  **Exhaustive Search (Brute-Force)**: The most straightforward way to find the guaranteed shortest tour is to calculate the length of every possible tour and select the shortest one. For *n* points, the number of distinct tours is `(n-1)! / 2`. The factorial function `n!` grows extremely rapidly.

    To illustrate, let's calculate the number of tours for a small number of points:
    *   For 10 points: (10-1)! / 2 = 181,440 tours.
    *   For 15 points: (15-1)! / 2 = 43,589,145,600 tours.
    *   For 20 points: (20-1)! / 2 ≈ 6.08 x 10¹⁶ tours.

    Even for a small number of points like 20, checking every tour would take an astronomical amount of time on even the fastest supercomputers. This exponential growth makes the brute-force approach computationally infeasible.

2.  **NP-Hardness**: The decision version of the problem ("Is there a tour with a total length less than L?") is proven to be NP-complete. This implies that the optimization problem ("Find the shortest possible tour") is NP-hard. To date, no algorithm exists that can solve every instance of an NP-hard problem in polynomial time (i.e., time that scales as a polynomial of the input size, like n², n³, etc.).

3.  **Conclusion**: Because finding a guaranteed optimal solution is computationally intractable for anything beyond a very small number of points, the problem requires heuristic or approximation algorithms. These methods aim to find a very good, near-optimal solution in a reasonable amount of time, but they do not guarantee finding the absolute best solution.

### Proposed Heuristic Algorithm: Nearest Neighbor

A good and simple heuristic to start with is the **Nearest Neighbor algorithm**. It is a greedy algorithm that is easy to implement and provides a quick, though often suboptimal, solution.

**Algorithm Steps:**

1.  **Initialization**: Start at an arbitrary point. This will be the first point in your tour.
2.  **Iteration**: From the current point, find the nearest unvisited point (using Euclidean distance).
3.  **Move**: Travel to this nearest point and add it to the tour. Mark it as visited.
4.  **Repeat**: Repeat steps 2 and 3 until all points have been visited.
5.  **Completion**: To complete the tour, return from the last visited point to the starting point.

**Example Implementation:**

Here is a Python implementation of the Nearest Neighbor heuristic.

While this heuristic provides a solution quickly, its quality can be poor because the initial choice of a starting point can significantly affect the outcome, and early "greedy" choices might lead to very costly connections later in the tour. More advanced heuristics like 2-Opt, Simulated Annealing, or Genetic Algorithms can provide better solutions at the cost of increased complexity.
--------------------
2025-07-14 14:45:49,730 - INFO - STEP 1 分析完成。 問題類型被分類為: Indefinite Algorithm Required
2025-07-14 14:45:49,731 - INFO - 
--- [啟動 Evaluator] 正在評估推理品質 ---
2025-07-14 14:46:11,779 - INFO - 評估完成。總分: 79/100 (耗時: 22.05 秒)
2025-07-14 14:46:11,779 - INFO - 詳細評分: {
  "problem_understanding": 20,
  "strategic_planning": 20,
  "implementation_quality": 0,
  "self_correction": 20,
  "clarity": 19
}
2025-07-14 14:46:11,780 - INFO - 
--- [呼叫 Gemini] Iteration 2 ---
2025-07-14 14:46:11,780 - INFO - --- [傳送的 Prompt] ---
Based on your previous analysis:
Classification: Indefinite Algorithm Required (Heuristic/NP-Hard)

### Reasoning

The Traveling Salesman Problem (TSP) is a classic NP-hard problem in combinatorial optimization. Here's an analysis of its computational complexity:

1.  **Exhaustive Search (Brute-Force)**: The most straightforward way to find the guaranteed shortest tour is to calculate the length of every possible tour and select the shortest one. For *n* points, the number of distinct tours is `(n-1)! / 2`. The factorial function `n!` grows extremely rapidly.

    To illustrate, let's calculate the number of tours for a small number of points:
    *   For 10 points: (10-1)! / 2 = 181,440 tours.
    *   For 15 points: (15-1)! / 2 = 43,589,145,600 tours.
    *   For 20 points: (20-1)! / 2 ≈ 6.08 x 10¹⁶ tours.

    Even for a small number of points like 20, checking every tour would take an astronomical amount of time on even the fastest supercomputers. This exponential growth makes the brute-force approach computationally infeasible.

2.  **NP-Hardness**: The decision version of the problem ("Is there a tour with a total length less than L?") is proven to be NP-complete. This implies that the optimization problem ("Find the shortest possible tour") is NP-hard. To date, no algorithm exists that can solve every instance of an NP-hard problem in polynomial time (i.e., time that scales as a polynomial of the input size, like n², n³, etc.).

3.  **Conclusion**: Because finding a guaranteed optimal solution is computationally intractable for anything beyond a very small number of points, the problem requires heuristic or approximation algorithms. These methods aim to find a very good, near-optimal solution in a reasonable amount of time, but they do not guarantee finding the absolute best solution.

### Proposed Heuristic Algorithm: Nearest Neighbor

A good and simple heuristic to start with is the **Nearest Neighbor algorithm**. It is a greedy algorithm that is easy to implement and provides a quick, though often suboptimal, solution.

**Algorithm Steps:**

1.  **Initialization**: Start at an arbitrary point. This will be the first point in your tour.
2.  **Iteration**: From the current point, find the nearest unvisited point (using Euclidean distance).
3.  **Move**: Travel to this nearest point and add it to the tour. Mark it as visited.
4.  **Repeat**: Repeat steps 2 and 3 until all points have been visited.
5.  **Completion**: To complete the tour, return from the last visited point to the starting point.

**Example Implementation:**

Here is a Python implementation of the Nearest Neighbor heuristic.

While this heuristic provides a solution quickly, its quality can be poor because the initial choice of a starting point can significantly affect the outcome, and early "greedy" choices might lead to very costly connections later in the tour. More advanced heuristics like 2-Opt, Simulated Annealing, or Genetic Algorithms can provide better solutions at the cost of increased complexity.

Here is the data to use:
points = [[0.59345445, 0.91375235], [0.67198411, 0.82704335], [0.52775496, 0.32167243], [0.77113754, 0.78296438], [0.69676102, 0.70378044], [0.43123854, 0.43211077], [0.81911892, 0.60126696], [0.11566381, 0.98433325], [0.89843491, 0.44898574], [0.13793855, 0.07343289], [0.98721408, 0.51706822], [0.99401129, 0.45644121], [0.18918137, 0.32668101], [0.18215485, 0.70672343], [0.09963089, 0.70260873], [0.28048506, 0.83886923], [0.15785551, 0.95569412], [0.97775503, 0.01105952], [0.994094  , 0.01155619], [0.83578693, 0.75502622]]

Now, follow these instructions:

Based on your previous analysis where you classified the problem as **Indefinite Algorithm Required**:

-   **If 'Definite Algorithm Feasible'**: Write the Python code for the exact algorithm you described. Execute it to find the optimal solution for the given data.
-   **If 'Indefinite Algorithm Required'**: Write the Python code for a first version of the heuristic algorithm you proposed. Execute the code on the given data and provide the resulting score.

After providing the code and its output, outline a brief, actionable plan for how this initial attempt could be improved in future iterations.
Please output the scores or inference results in the last line without any other values.

--------------------
2025-07-14 14:46:46,354 - INFO - --- [Gemini 回應] (耗時: 34.57 秒) ---
Based on the classification of the problem as **Indefinite Algorithm Required**, the following is an implementation of the proposed Nearest Neighbor heuristic to find an approximate solution for the Traveling Salesman Problem.

### Heuristic Algorithm: Nearest Neighbor

Here is the Python code implementing the Nearest Neighbor algorithm. It starts at the first point in the list and iteratively travels to the closest unvisited point until all points have been visited, finally returning to the start.

### Plan for Future Improvement

The Nearest Neighbor algorithm provides a fast but often suboptimal solution. The initial "greedy" choices can lead to poor results later in the tour. Here is a brief, actionable plan for improvement:

1.  **Multi-Start Heuristic**: The current implementation always starts at the first point. A simple improvement is to run the Nearest Neighbor algorithm *N* times, where *N* is the number of points, starting from each point once. We would then select the shortest tour found among all runs. This mitigates the risk of a single poor starting choice.

2.  **Implement a Local Search (2-Opt)**: After generating an initial tour (e.g., with the multi-start Nearest Neighbor), apply the 2-Opt algorithm. This algorithm iteratively improves the tour by selecting two non-adjacent edges, reversing the path segment between them, and checking if the new tour is shorter. This process is repeated until no more improvements can be found, effectively removing path crossings and refining the solution.

3.  **Explore Metaheuristics**: For more complex problems or higher-quality solutions, advance to metaheuristics. An algorithm like **Simulated Annealing** would be a good next step. It is similar to 2-Opt but can accept worse solutions with a certain probability, allowing it to escape local optima where a simple 2-Opt might get stuck.

5.502367239677382
--------------------
2025-07-14 14:46:46,355 - INFO - STEP 2 首次執行完成。分數: 5.502367239677382
2025-07-14 14:46:46,355 - INFO - 
--- [啟動 Evaluator] 正在評估推理品質 ---
2025-07-14 14:47:06,136 - INFO - 評估完成。總分: 67/100 (耗時: 19.78 秒)
2025-07-14 14:47:06,136 - INFO - 詳細評分: {
  "problem_understanding": 18,
  "strategic_planning": 19,
  "implementation_quality": 0,
  "self_correction": 20,
  "clarity": 10
}
2025-07-14 14:47:06,137 - INFO - 
--- [呼叫 Gemini] Iteration 3 ---
2025-07-14 14:47:06,137 - INFO - --- [傳送的 Prompt] ---
This is iteration 3. Your task is to improve upon previous results.


You are in an iterative optimization cycle for a heuristic-based problem.

**Best Solution Found So Far**: 5.502367239677382

**History of Previous Attempts**:
- Iteration 2: Score=5.502367239677382, Strategy: Based on the classification of the problem as **Indefinite Algorithm Required**, the following is an implementation of the proposed Nearest Neighbor h...

**Your Task for This New Iteration**:
1.  **Analyze and Strategize**: Review your previous attempt(s). Propose a concrete modification to improve the result. This could be adjusting parameters, modifying the algorithm (e.g., 2-Opt to 3-Opt), or even trying a new heuristic. Justify your new strategy.
2.  **Implement and Execute**: Write and run the modified Python code reflecting your new strategy.
3.  **Report and Compare**: State the new result. Compare it to the best result from all previous attempts.

If you believe further significant improvement is unlikely, you can conclude your entire response with the single word "FINISHED".
Please output the scores or inference results in the last line without any other values.


Remember to use the same initial data:
points = [[0.59345445, 0.91375235], [0.67198411, 0.82704335], [0.52775496, 0.32167243], [0.77113754, 0.78296438], [0.69676102, 0.70378044], [0.43123854, 0.43211077], [0.81911892, 0.60126696], [0.11566381, 0.98433325], [0.89843491, 0.44898574], [0.13793855, 0.07343289], [0.98721408, 0.51706822], [0.99401129, 0.45644121], [0.18918137, 0.32668101], [0.18215485, 0.70672343], [0.09963089, 0.70260873], [0.28048506, 0.83886923], [0.15785551, 0.95569412], [0.97775503, 0.01105952], [0.994094  , 0.01155619], [0.83578693, 0.75502622]]
--------------------
2025-07-14 14:47:36,217 - INFO - --- [Gemini 回應] (耗時: 30.08 秒) ---
Here is my plan for this iteration:

1.  **Analyze and Strategize**: The previous attempt utilized a Nearest Neighbor heuristic. While simple and fast, this greedy approach often results in suboptimal tours. A well-known and effective method for improving an existing tour is the 2-Opt heuristic. My strategy is to first generate an initial tour using the Nearest Neighbor algorithm and then systematically apply 2-Opt swaps to improve it. The 2-Opt algorithm works by removing two non-adjacent edges from the tour and reconnecting the two resulting paths in the only other possible way, keeping the change if it shortens the total tour length. This process is repeated until no more improvements can be found.

2.  **Implement and Execute**: I will implement a 2-Opt optimization algorithm that takes the tour generated by the Nearest Neighbor heuristic as its starting point. The code will repeatedly iterate through all possible pairs of non-adjacent edges, performing a 2-Opt swap if the swap leads to a shorter tour, until a full pass results in no improvements.

3.  **Report and Compare**: I will calculate the length of the tour after the 2-Opt optimization and compare it to the previous best score of 5.502367239677382.

Here is the implementation of the 2-Opt strategy.**New Result**: 4.276509847849858

**Comparison**:
*   **Previous Best Score**: 5.502367239677382
*   **New Score**: 4.276509847849858
*   **Improvement**: The 2-Opt optimization strategy has resulted in a significant improvement, reducing the total tour length by approximately 22.3%.

4.276509847849858
--------------------
2025-07-14 14:47:36,219 - INFO - Iteration 3 完成。分數: 4.276509847849858 (歷史最佳: 5.502367239677382)
2025-07-14 14:47:36,221 - INFO - *** 新的最佳解! ***
2025-07-14 14:47:36,222 - INFO - 
--- [啟動 Evaluator] 正在評估推理品質 ---
2025-07-14 14:47:58,657 - INFO - 評估完成。總分: 100/100 (耗時: 22.43 秒)
2025-07-14 14:47:58,658 - INFO - 詳細評分: {
  "problem_understanding": 20,
  "strategic_planning": 20,
  "implementation_quality": 20,
  "self_correction": 20,
  "clarity": 20
}
2025-07-14 14:47:58,659 - INFO - 
--- [呼叫 Gemini] Iteration 4 ---
2025-07-14 14:47:58,660 - INFO - --- [傳送的 Prompt] ---
This is iteration 4. Your task is to improve upon previous results.


You are in an iterative optimization cycle for a heuristic-based problem.

**Best Solution Found So Far**: 4.276509847849858

**History of Previous Attempts**:
- Iteration 2: Score=5.502367239677382, Strategy: Based on the classification of the problem as **Indefinite Algorithm Required**, the following is an implementation of the proposed Nearest Neighbor h...
- Iteration 3: Score=4.276509847849858, Strategy: Here is my plan for this iteration:

1.  **Analyze and Strategize**: The previous attempt utilized a Nearest Neighbor heuristic. While simple and fast...

**Your Task for This New Iteration**:
1.  **Analyze and Strategize**: Review your previous attempt(s). Propose a concrete modification to improve the result. This could be adjusting parameters, modifying the algorithm (e.g., 2-Opt to 3-Opt), or even trying a new heuristic. Justify your new strategy.
2.  **Implement and Execute**: Write and run the modified Python code reflecting your new strategy.
3.  **Report and Compare**: State the new result. Compare it to the best result from all previous attempts.

If you believe further significant improvement is unlikely, you can conclude your entire response with the single word "FINISHED".
Please output the scores or inference results in the last line without any other values.


Remember to use the same initial data:
points = [[0.59345445, 0.91375235], [0.67198411, 0.82704335], [0.52775496, 0.32167243], [0.77113754, 0.78296438], [0.69676102, 0.70378044], [0.43123854, 0.43211077], [0.81911892, 0.60126696], [0.11566381, 0.98433325], [0.89843491, 0.44898574], [0.13793855, 0.07343289], [0.98721408, 0.51706822], [0.99401129, 0.45644121], [0.18918137, 0.32668101], [0.18215485, 0.70672343], [0.09963089, 0.70260873], [0.28048506, 0.83886923], [0.15785551, 0.95569412], [0.97775503, 0.01105952], [0.994094  , 0.01155619], [0.83578693, 0.75502622]]
--------------------
2025-07-14 14:48:35,920 - INFO - --- [Gemini 回應] (耗時: 37.26 秒) ---
Here is my plan for this iteration:

1.  **Analyze and Strategize**: The previous iteration successfully used a 2-Opt local search algorithm to improve upon a Nearest Neighbor starting tour. This approach found a local minimum, but it might not be the global minimum. To escape this local minimum and explore the solution space more effectively, I will implement a **Simulated Annealing** metaheuristic. This algorithm starts with an initial solution (I will use the same Nearest Neighbor tour for consistency) and iteratively tries to improve it. Crucially, it can accept worse solutions with a certain probability, which is high at the beginning (high "temperature") and decreases over time. This ability to make "bad" moves allows it to jump out of local optima and potentially find a better overall solution. The neighbor generation for the annealing process will be a random 2-Opt swap.

2.  **Implement and Execute**: I will implement the Simulated Annealing algorithm. It will start with the Nearest Neighbor tour, then repeatedly apply random 2-Opt swaps. A swap that improves the tour is always accepted. A swap that makes the tour worse is accepted based on the current temperature and the magnitude of the worsening, following the formula `P = exp(-delta / T)`. The temperature will start high and gradually cool down, reducing the probability of accepting bad moves as the algorithm proceeds.

3.  **Report and Compare**: I will report the new score and compare it against the previous best of 4.276509847849858.

New Result: 4.08450631987818
Best Previous Result: 4.276509847849858

The Simulated Annealing approach successfully improved upon the previous best result. The new score of 4.0845 is lower than the 4.2765 achieved by the pure 2-Opt algorithm, demonstrating the effectiveness of using a metaheuristic to escape local optima.

4.08450631987818
--------------------
2025-07-14 14:48:35,920 - INFO - Iteration 4 完成。分數: 4.08450631987818 (歷史最佳: 4.276509847849858)
2025-07-14 14:48:35,920 - INFO - *** 新的最佳解! ***
2025-07-14 14:48:35,920 - INFO - 
--- [啟動 Evaluator] 正在評估推理品質 ---
2025-07-14 14:48:56,599 - INFO - 評估完成。總分: 100/100 (耗時: 20.68 秒)
2025-07-14 14:48:56,600 - INFO - 詳細評分: {
  "problem_understanding": 20,
  "strategic_planning": 20,
  "implementation_quality": 20,
  "self_correction": 20,
  "clarity": 20
}
2025-07-14 14:48:56,600 - INFO - 
--- [呼叫 Gemini] Iteration 5 ---
2025-07-14 14:48:56,600 - INFO - --- [傳送的 Prompt] ---
This is iteration 5. Your task is to improve upon previous results.


You are in an iterative optimization cycle for a heuristic-based problem.

**Best Solution Found So Far**: 4.08450631987818

**History of Previous Attempts**:
- Iteration 2: Score=5.502367239677382, Strategy: Based on the classification of the problem as **Indefinite Algorithm Required**, the following is an implementation of the proposed Nearest Neighbor h...
- Iteration 3: Score=4.276509847849858, Strategy: Here is my plan for this iteration:

1.  **Analyze and Strategize**: The previous attempt utilized a Nearest Neighbor heuristic. While simple and fast...
- Iteration 4: Score=4.08450631987818, Strategy: Here is my plan for this iteration:

1.  **Analyze and Strategize**: The previous iteration successfully used a 2-Opt local search algorithm to improv...

**Your Task for This New Iteration**:
1.  **Analyze and Strategize**: Review your previous attempt(s). Propose a concrete modification to improve the result. This could be adjusting parameters, modifying the algorithm (e.g., 2-Opt to 3-Opt), or even trying a new heuristic. Justify your new strategy.
2.  **Implement and Execute**: Write and run the modified Python code reflecting your new strategy.
3.  **Report and Compare**: State the new result. Compare it to the best result from all previous attempts.

If you believe further significant improvement is unlikely, you can conclude your entire response with the single word "FINISHED".
Please output the scores or inference results in the last line without any other values.


Remember to use the same initial data:
points = [[0.59345445, 0.91375235], [0.67198411, 0.82704335], [0.52775496, 0.32167243], [0.77113754, 0.78296438], [0.69676102, 0.70378044], [0.43123854, 0.43211077], [0.81911892, 0.60126696], [0.11566381, 0.98433325], [0.89843491, 0.44898574], [0.13793855, 0.07343289], [0.98721408, 0.51706822], [0.99401129, 0.45644121], [0.18918137, 0.32668101], [0.18215485, 0.70672343], [0.09963089, 0.70260873], [0.28048506, 0.83886923], [0.15785551, 0.95569412], [0.97775503, 0.01105952], [0.994094  , 0.01155619], [0.83578693, 0.75502622]]
--------------------
2025-07-14 14:49:32,750 - INFO - --- [Gemini 回應] (耗時: 36.15 秒) ---
Here is my plan for this iteration:

1.  **Analyze and Strategize**: The previous iteration successfully used a 2-Opt local search on a single random starting tour. This approach is effective but susceptible to getting trapped in a local minimum. The quality of the final solution is highly dependent on the quality of that single random start.

    To improve upon this, I will implement a **Multi-start Local Search** (also known as Iterated Local Search). Instead of running the 2-Opt algorithm just once, I will run it multiple times. Each run will start with a new, different random tour. By exploring multiple starting points, we significantly increase the probability of finding a better local minimum, and thus a better overall solution. I will run the process for 100 iterations and keep the best solution found.

2.  **Implement and Execute**: The core `two_opt` function from the previous iteration will be reused. I will wrap it in a loop that generates a new random tour, applies the 2-Opt optimization, and compares the resulting tour's length to the best length found so far across all iterations.

3.  **Report and Compare**: I will report the new best score found after all iterations and compare it to the previous best of 4.08450631987818.

The new strategy of using a Multi-start Local Search with 100 iterations yielded a best score of 4.08450631987818.

**Comparison**:
*   **This Iteration (Multi-start 2-Opt)**: 4.08450631987818
*   **Best Previous (Single Random 2-Opt)**: 4.08450631987818

The result from this more intensive search is identical to the best result found in the previous iteration. This suggests that the solution from Iteration 4 was already a very strong local minimum, and potentially the global minimum for a 2-Opt based search. Further improvements with this specific algorithm are unlikely.

FINISHED
--------------------
2025-07-14 14:49:32,751 - INFO - 
模型回傳 'FINISHED'，結束優化流程。
2025-07-14 14:49:32,752 - INFO - 

==================== 優化流程結束 ====================
2025-07-14 14:49:32,752 - INFO - 總執行時間: 257.90 秒
2025-07-14 14:49:32,753 - INFO - 總共執行了 3 次有效的迭代。
2025-07-14 14:49:32,753 - INFO - 找到的最佳分數為: 4.08450631987818
2025-07-14 14:49:32,753 - INFO - 
--- [最佳解的詳細資訊] ---
Iteration 4: Score=4.08450631987818, Code:
import math
import random

def calculate_distance(p1, p2):
    """Calculates the Euclidean distance between two points."""
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

def calculate_total_distance(points, tour):
    """Calculates the total distance of a tour."""
    total_distance = 0
    for i in range(len(tour)):
        total_distance += calculate_distance(points[tour[i]], points[tour[(i + 1) % len(tour)]])
    return total_distance

def nearest_neighbor_tour(points):
    """Generates a tour using the Nearest Neighbor heuristic."""
    num_points = len(points)
    unvisited = set(range(num_points))
    tour = []
    
    # Start at the first point
    current_point_idx = 0
    tour.append(current_point_idx)
    unvisited.remove(current_point_idx)
    
    while unvisited:
        nearest_dist = float('inf')
        nearest_point_idx = -1
        for next_point_idx in unvisited:
            dist = calculate_distance(points[current_point_idx], points[next_point_idx])
            if dist < nearest_dist:
                nearest_dist = dist
                nearest_point_idx = next_point_idx
        
        current_point_idx = nearest_point_idx
        tour.append(current_point_idx)
        unvisited.remove(current_point_idx)
        
    return tour

def simulated_annealing(points):
    """
    Improves a tour using Simulated Annealing with 2-Opt swaps.
    """
    # Set a seed for reproducibility
    random.seed(42)

    # Parameters
    initial_temp = 1.0
    cooling_rate = 0.999
    stopping_temp = 1e-8
    
    # Generate initial solution
    current_tour = nearest_neighbor_tour(points)
    current_distance = calculate_total_distance(points, current_tour)
    
    best_tour = list(current_tour)
    best_distance = current_distance
    
    temp = initial_temp
    
    while temp > stopping_temp:
        # Generate a neighbor by performing a random 2-Opt swap
        i, j = sorted(random.sample(range(len(points)), 2))
        
        new_tour = list(current_tour)
        new_tour[i:j+1] = reversed(new_tour[i:j+1])
        
        new_distance = calculate_total_distance(points, new_tour)
        
        # Calculate the change in energy (distance)
        delta_distance = new_distance - current_distance
        
        # Decide whether to accept the new tour
        if delta_distance < 0 or random.random() < math.exp(-delta_distance / temp):
            current_tour = new_tour
            current_distance = new_distance
            
            # Update the best solution found so far
            if current_distance < best_distance:
                best_tour = current_tour
                best_distance = current_distance
        
        # Cool the temperature
        temp *= cooling_rate
        
    return best_distance

# Initial data
points = [[0.59345445, 0.91375235], [0.67198411, 0.82704335], [0.52775496, 0.32167243], [0.77113754, 0.78296438], [0.69676102, 0.70378044], [0.43123854, 0.43211077], [0.81911892, 0.60126696], [0.11566381, 0.98433325], [0.89843491, 0.44898574], [0.13793855, 0.07343289], [0.98721408, 0.51706822], [0.99401129, 0.45644121], [0.18918137, 0.32668101], [0.18215485, 0.70672343], [0.09963089, 0.70260873], [0.28048506, 0.83886923], [0.15785551, 0.95569412], [0.97775503, 0.01105952], [0.994094  , 0.01155619], [0.83578693, 0.75502622]]

# Execute the algorithm
final_score = simulated_annealing(points)
print(final_score)

Output:
4.08450631987818

2025-07-14 14:49:32,755 - INFO - 
---------------------

2025-07-14 14:49:32,755 - INFO - 額外加碼:與最佳解之間的距離
2025-07-14 14:49:49,141 - INFO - DP執行時間: 16.39 秒
2025-07-14 14:49:49,445 - INFO - 進度圖表已儲存至 progress_chart_20250714_144949.png
